Bruce Cosgrove
CS 260

1) How well did the data structure selected perform for the assigned application?
I do like that the Websites were sorted, although, that's just a consequence of 
using a Binary Search Tree. Then again, by that definition, it did it's job, and 
rather nicely, I might add. Once I figured out what to do, it was all relatively 
simple, when compared to the project #3. In factm I'd argue that this is a 
better way entirely to implement... whatever it is projects 3 & 4 were based on.
Maybe a rudimentary version of boommarks?

2) Would a different data structure work better? If so, which one and why...
Better... in what sense? I can think of a lot of things the BST did better at 
than the HashTable. For example: Websites automatically sorted, access time is 
faster, no required arrays nor possible duplicates, less memory usage, etc.
Wow, this is starting to turn into an answer to question #3, so let's just go
there.

3) What was efficient about your design and use of the data structure?
No extra code was required to sort the Websites when printing, it all just 
happened as a consequence of using a BST. It was easier to code and made much 
more sense than the first couple of hours of work that I accidently deleted.
But I'm so glad I did that because it was a nightmare to try and figure out 
anything. (continued in #4 VVVVVV)

4) What was not efficient?
For starters, it wouldn't have even been classified as a BST because it was NOT 
sorted in the slightest. In fact, I manually sorted the Websites for printing 
them alphabetically. Fortunately, once I deleted that work, I realized all that.
That's a reason why I like starting from scratch.

5) What would you do differently if you had more time to solve the problem?
One thing is I would make some functions in the WebTree easier to use. Their 
parameters and return values, mostly Node* remove(Node*, const char*, bool&)
was quite cluttered and could have been reduced to 
bool remove(Node*&, const char*). Not to mention the bool notUsed; in 
void remove(Node*&).
